====== NAO hraje hru s kostkou ======
===== Tım =====
**Adam Kugler**

**Jakub Koza**
===== Cíle =====
Jako cíl našeho projektu jsme si zvolili vytvoøit jednoduchou hru s kostkou, pro dva nebo více hráèù, kde by se NAO aktivnì úèastnil hry a zárovìn vyhodnocoval vısledky (rozpoznal, co na kostce padlo, a urèil vítìze). Náplní tohoto projektu bylo vytvoøit modul pro rozpoznávání hodnoty padlé na kostce, naplánovat pohyby a vše logicky sesadit dohromady v Choreographe.

===== Analıza =====
Pùvodní verze našeho projektu poèítala s vyuitím programu na rozpoznávání padlé hodnoty na kostce, kterou ji naprogramoval náš pøedchùdce Vojtìch Haur v jednom z pøedchozích semestrù. (link: https://edux.fit.cvut.cz/courses/MI-IVS/labs/mi_ivs_prj/rozpoznavani_kostky) Program byl celı napsán v programovacím jazyce Java, kterı ovládá robota pøes NAOqi's java binding, jinak známé jako JNaoQi. Bohuel pro naše úèely bylo potøeba kromì rozpoznávání kostky implementovat i motoriku robota, která by byla zbyteènì nároèná na implementaci v jazyce Java. Proto jsme se rozhodli, e vyuijeme nástroj Choreographe pro implementaci chování robota a celou èást rozpoznávání kostky implementujeme jako jeden modul, se kterım bude øešení v Choreographe pouze spolupracovat ve fázi, kdy je potøeba zjistit poèet bodù na kostce. Pro pouití tohoto øešení však bylo potøeba pøepsat rozpoznávání kostky, z Javy do C++ (pøípadnì Python), jeliko souèasné API neumoòuje napsání modulu v programovacím jazyce Java.

===== Øešení =====
Veškerá motorika robota je implementována pomocí nástroje Choreographe, ve kterém se funkcionalita zadává pomocí spojování urèitıch funkèních èástí do jistého druhu flow diagramu. Kadá funkèní èást mùe mít více vstupù i vıstupù, a dokonce mohou ve svém vıstupu posílat hodnotu v urèeném datovém typu. Vıhodou je, e lze vytvoøit vlastní funkèní celek za pomoci programovacího jazyka Python, kterı v tomto projektu pouíváme napøíklad pro napojení na námi vytvoøenı modul pro rozpoznávání poètu bodù na kostce (programovanı v C++), nebo také pro prùbìné pamatování vısledkù hodù a vyhodnocení hry.

Obecnì modul do robota NAO mùe bıt buï remote, nebo local. Remote znamená, e vlastní zdrojovı kód modulu bìí v poèítaèi, na kterém je remote modul spušìn a do robota je pouze nahrán proxy objekt, kterı poadavky deleguje skrze síové pøipojení na poèítaè za pomoci protokolu SOAP. Local modul bìí pøímo na robotovi a není tak potøeba ádnı pøenos po síti. Nevıhodou lokálního modulu je sloitìjší nasazování na robota, jeliko je nutné manuální pøekopírování do jeho pamìového uloištì napøíklad pomocí ssh. Pøepnutí mezi jednotlivımi typy modulù je pouze ve zmìnì konfiguraèního souboru pro kompilaci zdrojovıch kódù a je tedy nutné si pouze vybrat, zda pro rozpoznání vyuít vyššího vıkonu poèítaèe, avšak zpomalení na síti pøi pøenášení obrazu (remote modul), nebo zda nepøenášet po síti nic a nechat robota rozpoznat obraz na pomalejším procesoru robota. 

==== Rekvizity ====
Vzhledem k tomu, e jsme vytváøeli hru s kostkou pro robota NAO museli jsme si opatøit nìkolik rekvizit. V první øadì to byla kostka, kterou nám zapùjèil pan doktor Skrbek, ale vzhledem k nešastné barvì vùèi podlaze v uèebnì (bílá/šedá), jsme museli vytvoøit také podklad kontrastní barvy ve formì krabice, co se pozdìji ukázalo jako velmi vıhodné.

=== Kostka ===
Plyšová bílá kostka s èervenımi puntíky, která je pøimìøenì veliká a mìkká, aby ji mohl robot uchopit.

=== Krabice ===
Krabice bez víka se zelenım vnitøkem a èernım vnìjškem. Slouí jako, podklad pro lepší rozpoznávání bez ohledu na prostøedí. Také zaruèuje, e kostka nepadne mimo zornı úhel robota.

== Správné umístìní krabice ==
Jakmile NAO stojí, je nutné umístit krabici tak, aby se robot dotıkal špièkami u nohou jejího delšího okraje, byla dnem na zemi a byla vycentrovaná na osu robota.

==== Rozpoznávání kostky ====
Celı modul pro rozpoznávání poètu bodù na kostce je programovanı v jazyce C++ za pouití knihovny pro pokroèilé zpracování obrazu OpenCV. Modul má název DieModule a jeho rozhraní poskytuje jedinou funkci s názvem findOutThrownCount, která nemá ádné parametry a návratovou hodnotou je èíslo typu int. Toto èíslo se rovná buï rozpoznané hodnotì bodù padlé na kostce, nebo hodnotì -1, která signalizuje, e kostka na obrázku nebyla správnì rozpoznána (teoreticky vrací i hodnotu 0 v pøípadì, e se modulu nepodaøilo poøídit fotku jeho spodní kamerou, avšak toto by v reálném pøípadì nemìlo nastat).

==== Choreographe ====
Hlavním dùvodem pouití tohoto nástoroje byla snadná a elegantní práce s pohyby robota. Mìli jsme nìkolik úkolù, které bylo potøeba vyøešit.
=== Interakce s robotem ===
Uivatel interaguje s robotem, pomocí jeho tlakovıch senzorù a tím se posouvá do další fáze hry, jedná se o potvrzení, e hráè udìlal, co mu robot øekl (podání kostky/hod kostkou). Pùvodnì jsme chtìli (kvùli pøirozenosti) pouít i jiné tlakové senzory, ne ty na hlavì, ale ukázalo se, e jsou málo spolehlivé, proto pouíváme pouze prostøední tlakovı senzor na hlavì robota.

=== Pohyby ===
Základní otázkou bylo, jak se bude robot hıbat, aby vypadal pøirozenì.

== Vypnutí samovolnıch pohybù ==
Samovolné pohyby jsou jistì efektní a pøirozené, ale pro naše úèely jsme potøebovali aby se robot díval kam má a nestrkal ruce kam nemá, proto bylo nutné veškeré samovolné pohyby robota vypnout.

== Pozice pøi rozpoznávání ==
Mìli jsme dvì monosti, buï jsme mohli kostku rozpoznávat s jakékoli pozice, co by mìlo vyšší nároky na rozpoznávání a potøebovali bychom záruku toho, e se kostka nachází v zorném poli robota, nebo jsme mohli zvolit specifickou pozici, ze které budu rozpoznáváni probíhat. Našim potøebám lépe vyhovovala druhá monost, proto jsme ji také zvolili. 

V této fázi jsme ji vìdìli, e se robot bude dívat do krabice. Chtìli jsme samozdøejmì vymyslet pozici, ze které bude rozpoznávání nejsnazší. Nejlépe by nám vyhovoval snímek, poøízenı kolmo na vrchní stranu kostky. Robotova hlava by se tedy musela dostat pøímo nad kostku/krabici, ale robot nemá ohebnı trup, tudí by se do této polohy dostával velmi obtínì a navíc by to nevypadalo pøirozenì a ješte by si stínil svou vlastní hlavou.

Rozhodli jsme se tedy pro kompromis mezi rozpoznáváním a pozicováním robota. Vısledná poloha je velmi jednoduchá a pøirozená, jedná se o základní postoj robota poté, co vstane, akorát si maximálnì skloní hlavu. Trik spoèívá v tom, e snímek se poøídí spodní kamerou. K našemu pøekvapení, tento snímek zachytává celou krabici s minimálními okraji okolního prostøedí.

== Házení kostkou ==
Dùleitım pohybem je urèitì samotné házení kostkou, které se skládá ze 3 pozic a otevírání/zavírání ruky. Jedná se vlastnì pouze o pohyb pravé ruky, zatímco robot stojí. Robot je odkázán na to, e mu uivatel kostku podá do ruky, on ji pak sevøe a hodí nebo spíše upustí do krabice. Hod vypadá celkem pøirozenì, ale je velmi jednoduchı a moná by si zaslouil vylepšení, protoe kostka èasto padá do odlehlıch koutù krabice, kde je rozpoznávání nejménì spolehlivé.

=== Mluvení ===
Samozøejmì celou hru doprovází NAO mluvením v èeštinì. Na zaèátku vysvìtlí pravidla, dále kontroluje prùbìh hry (øíká, kdo je na øadì) a hlásí jím rozpoznané vısledky a u hodu nebo celé hry.

=== Logika ===
Logika je jistì správné pospojování krabièek v Choreographe, ale dùleitım problémem bylo, jak si pamatovat a vyhodnocovat vısledky hry. K tomu bylo nutné vytvoøit Python script.

== Zapamatování a vyhodnocení vısledkù ==
Protoe se hra hraje na dva hody (hází robot/hází hráè), bylo nutné si uschovat vısledek prvního hodu a po druhém hodu vyhodnotit, kdo toho kolo vyhrál. K tomu sloí námi vytvoøenı script. Vyhodnocení celkového vısledku se muselo ještì synchronizovat s vyhodnocením vısledku druhého hodu.

===== Vısledky =====
==== Hra ====
=== Princip hry ===
  * Hra pro 2 hráèe (NAO, èlovìk)
  * Oba hází kostkou do krabice
  * NAO rozpoznává, co padlo na kostce
  * Vyhrává ten kdo hodí víc
=== Prùbìh hry ===
  - NAO vysvìtlí pravidla hry
  - NAO je první na øadì
  - NAO poádá o podání kostky
  - Protihráè mu dá kostku a pohladí ho, aby robot kostku uchopil
  - NAO uchopí kostku a hodí ji do krabice
  - NAO zaujme pozorovací pozici, poøídí snímek a rozpozná, co na kostce padlo
  - NAO øekne, co rozpoznal a oznámí protihráèi, e mùe házet
  - Protihráè hodí kostu do krabice a pohladí robota na znamení, e mùe zaèít rozpoznávat
  - NAO zaujme pozorovací pozici, poøídí snímek a rozpozná, co na kostce padlo
  - NAO øekne, co rozpoznal a oznámí protihráèi vısledek hry
  - Hra pokraèuje od bodu 2

  * Pokud dojde k chybì pøi rozpoznávání, NAO nevidí kostku, bude se hod opakovat
  * Pokud dojde k chybì pøi rozpoznávání a NAO špatnì vyhodnotí, co padlo, hra pokraèuje dál, jako by to bylo správnì. Nepøedpokládá se, e by se NAO spletl. 

==== Dílèí èásti ====
=== Modul pro rozpoznávání kostky ===
Modul, kterı je schopen, rozpoznat kostku zmiòovanou v èásti kostka, a urèit, kolik na ní padlo. Modul také pøedpokládá pouití krabice se zelenım vnitøkem a specifickou pozici robota. 

===== Moná vylepšení a rozšíøení =====
==== Vylepšení rozpoznávacího algoritmu ====
==== Vylepšení pohybù a prezentace robota ====
Protoe hra byla a sekundární cíl tohoto projektu, nejsou pohyby ani prezentace robota moc propracovány, je to spíše taková kostra. Urèitì by stálo za to podání této hry vylepšit, a u lepšími komentáøi robota nebo propracovanìjšími pohyby, tøeba i bìhem analızy obrazu.

==== Jiná hra s kostkou ====
Tato hra je v podstatì nìjjednodušší, která se dá s kostkou hrát, ale jsou zde implementovány všechny dùleité stavební kameny, ze kterıch lze celkem snadno vyrobit mnohem sofistikovanìjší hru.




====== NAO hraje hru s kostkou ======
===== Tım =====
**Adam Kugler**

**Jakub Koza**
===== Cíle =====
Jako cíl našeho projektu jsme si zvolili vytvoøit jednoduchou hru s kostkou, pro dva nebo více hráèù, kde by se NAO aktivnì úèastnil hry a zárovìn vyhodnocoval vısledky (rozpoznal, co na kostce padlo, a urèil vítìze). Náplní tohoto projektu bylo vytvoøit modul pro rozpoznávání hodnoty padlé na kostce, naplánovat pohyby a vše logicky sesadit dohromady v Choreographe.
===== Analıza =====
Pùvodní verze našeho projektu poèítala s vyuitím programu na rozpoznávání padlé hodnoty na kostce, kterou ji naprogramoval náš pøedchùdce Vojtìch Haur v jednom z pøedchozích semestrù. (link: https://edux.fit.cvut.cz/courses/MI-IVS/labs/mi_ivs_prj/rozpoznavani_kostky) Program byl celı napsán v programovacím jazyce Java, kterı ovládá robota pøes NAOqi's java binding, jinak známé jako JNaoQi. Bohuel pro naše úèely bylo potøeba kromì rozpoznávání kostky implementovat i motoriku robota, která by byla zbyteènì nároèná na implementaci v jazyce Java. Proto jsme se rozhodli, e vyuijeme nástroj Choreographe pro implementaci chování robota a celou èást rozpoznávání kostky implementujeme jako jeden modul, se kterım bude øešení v Choreographe pouze spolupracovat ve fázi, kdy je potøeba zjistit poèet bodù na kostce. Pro pouití tohoto øešení však bylo potøeba pøepsat rozpoznávání kostky, z Javy do C++ (pøípadnì Python), jeliko souèasné API neumoòuje napsání modulu v programovacím jazyce Java.
===== Øešení =====
Veškerá motorika robota je implementována pomocí nástroje Choreographe, ve kterém se funkcionalita zadává pomocí spojování urèitıch funkèních èástí do jistého druhu flow diagramu. Kadá funkèní èást mùe mít více vstupù i vıstupù, a dokonce mohou ve svém vıstupu posílat hodnotu v urèeném datovém typu. Vıhodou je, e lze vytvoøit vlastní funkèní celek za pomoci programovacího jazyka Python, kterı v tomto projektu pouíváme napøíklad pro napojení na námi vytvoøenı modul pro rozpoznávání poètu bodù na kostce (programovanı v C++), nebo také pro prùbìné pamatování vısledkù hodù a vyhodnocení hry.

Obecnì modul do robota NAO mùe bıt buï remote, nebo local. Remote znamená, e vlastní zdrojovı kód modulu bìí v poèítaèi, na kterém je remote modul spušìn a do robota je pouze nahrán proxy objekt, kterı poadavky deleguje skrze síové pøipojení na poèítaè za pomoci protokolu SOAP. Local modul bìí pøímo na robotovi a není tak potøeba ádnı pøenos po síti. Nevıhodou lokálního modulu je sloitìjší nasazování na robota, jeliko je nutné manuální pøekopírování do jeho pamìového uloištì napøíklad pomocí ssh. Pøepnutí mezi jednotlivımi typy modulù je pouze ve zmìnì konfiguraèního souboru pro kompilaci zdrojovıch kódù a je tedy nutné si pouze vybrat, zda pro rozpoznání vyuít vyššího vıkonu poèítaèe, avšak zpomalení na síti pøi pøenášení obrazu (remote modul), nebo zda nepøenášet po síti nic a nechat robota rozpoznat obraz na pomalejším procesoru robota. 

==== Rozpoznávání kostky ====
Celı modul pro rozpoznávání poètu bodù na kostce je programovanı v jazyce C++ za pouití knihovny pro pokroèilé zpracování obrazu OpenCV. Modul má název //DieModule// a jeho rozhraní poskytuje jedinou funkci s názvem //findOutThrownCount//, která nemá ádné parametry a návratovou hodnotou je èíslo typu //int//. Toto èíslo se rovná buï rozpoznané hodnotì bodù padlé na kostce, nebo hodnotì -1, která signalizuje, e kostka na obrázku nebyla správnì rozpoznána (teoreticky vrací i hodnotu 0 v pøípadì, e se modulu nepodaøilo poøídit fotku jeho spodní kamerou, avšak toto by v reálném pøípadì nemìlo nastat).

Rozpoznávání kostky z obrázku probíhá v nìkolika fázích, které budou popsány v následujícím textu na názorném pøíkladì. Toto je napøíklad obrázek kostky zachycenı spodní kamerou robota v rozlišení 640x480 pixelù:
 
{{:student:kozajaku:faze1.jpg|}} 

Na obrázku je moné si všimnout ještì prstù robota, které zde však v novìjší souèasné verzi programu vidìt nejsou, take nebrání rozpoznávání v pøípadì padnutí kostky do pøedních rohù krabice. Pro zpøesnìní vyhledání kostky na obrazu jsme vyuili zeleného pozadí krabice, take logicky prvním krokem je vyprahování pozadí a zanechání pouze tìch èástí obrazu, které by teoreticky mohly bıt kostkou. Pro dosaení tohoto vısledku je obraz nejdøíve pøeveden do HSV barevného schématu a následnì vyprahován do následujícího binárního obrazu pomocí mezí pro zelenou barvu vnitøku krabice (pro pøevod a prahování je vyuito OpenCV).

{{:student:kozajaku:faze2.jpg|}} 

Nyní lze pøedpokládat, e kostka se nachází uvnitø detekovaného pozadí, take pro zjednodušení následujícího zpracování lze odstranit èerné okraje binárního obrazu kolem detekovaného pozadí. Po vymaskování pozadí vypadá pùvodní obraz takto:

{{:student:kozajaku:faze3.jpg|}} 

 Z tohoto obrazu je nyní potøeba barevnì vyprahovat tìlo samotné kostky a bodíky, které se na kostce nachází. K tomu je opìt pouit stejnı zpùsob jako pøi vyprahovávání pozadí tedy pøevod do barevného schématu HSV a následnì pouití funkce OpenCV k vyprahování podle námi namìøenıch dolních a horních HSV mezí. Tyto meze jsou zadány ve zdrojovém kódu jako konstanty a lze je volnì upravovat v pøípadì zmìny hrací kostky. Vısledné vyprahované binární obrazy lze vidìt na následujících obrázcích.
 
{{:student:kozajaku:faze4_1.jpg|}}  {{:student:kozajaku:faze4_2.jpg|}} 
 
Dalším krokem je detekce hran na binárních obrazech s tìlem kostky a jejími body a nafitování elipsy na tyto hrany tak, abychom získali pøiblinı vektorovı pøehled o objektech, které se zde nacházejí. K tomuto kroku jsou pouity funkce //findContours// a //fitEllipse// z knihovny OpenCV. Následující obrázek demonstruje nalezení elips pomocí tìchto funkcí. 

{{:student:kozajaku:faze5.jpg|}} 

Na obraze je vidìt, e došlo k detekci i artefaktù zvláštních tvarù èi velikostí, o kterıch mùeme jistì øíci, e se nejedná o kostku nebo její body. Kadou elipsu tedy projdeme a oprahujeme podle rozmìrù na šíøku a na vıšku, abychom vyøadili elipsy, které jsou pøíliš malé (nepøesnosti v obraze), nebo naopak pøíliš velké (napøíklad velkı kruh z dùvodu pøesvìtlení vnitøku krabice). Podle velikosti také mùeme usoudit, zda se jedná o elipsu reprezentující tìlo kostky, nebo o elipsu reprezentující bod na kostce (musí mít správnou velikost a nacházet se uvnitø tìla kostky).

{{:student:kozajaku:faze6.jpg|}} 

Posledním nejzásadnìjším krokem je zjistit, které body detekované na kostce jsou na horní stìnì kostky. K tomuto úèelu vytvoøíme speciální novou elipsu reprezentující horní stìnu, která vychází z velikosti a polohy elipsy tìla kostky a následnì je její velikost (èásteènì i poloha) upravena podle polohy tìla kostky na obraze. Názornì èím více je kostka vlevo/vpravo od støedu nebo èím více je kostka na obraze vıše (chápejme dále od robota), tím je tato elipsa menší. Závislost na zmìnì polohy je lineární a lineární rovnice byly vypoèteny na základì praktického testování. Pøestoe tato metoda je velice jednoduchá, vykazuje velice dobré vısledky a prakticky selhává pouze v nìkterıch krajních pøípadech, kdy se kostka nachází ve velké vzdálenosti od robota a je specificky natoèena (napøíklad v zadním rohu). Nyní zbıvá jen spoètení elips na horní stìnì kostky a vrácení vısledku rozpoznávání.

{{:student:kozajaku:faze7.jpg|}}  
  

==== Rekvizity ====
=== Kostka ===
Plyšová bílá kostka s èervenımi puntíky, která je pøimìøenì veliká a mìkká, aby ji mohl robot uchopit.
=== Krabice ===
Krabice bez víka se zelenım vnitøkem a èernım vnìjškem. Slouí jako, podklad pro lepší rozpoznávání bez ohledu na prostøedí. Také zaruèuje, e kostka nepadne mimo zornı úhel robota.
== Správné umístìní krabice ==
Jakmile NAO stojí, je nutné umístit krabici tak, aby se robot dotıkal špièkami u nohou jejího delšího okraje, byla dnem na zemi a byla vycentrovaná na osu robota.
==== Pohyby v Choreographe ====
==== Logika v Choreographe ====
===== Vısledky =====
==== Hra ====
=== Princip hry ===
  * Hra pro 2 hráèe (NAO, èlovìk)
  * Oba hází kostkou do krabice
  * NAO rozpoznává, co padlo na kostce
  * Vyhrává ten kdo hodí víc
=== Prùbìh hry ===
  - NAO vysvìtlí pravidla hry
  - NAO je první na øadì
  - NAO poádá o podání kostky
  - Protihráè ho pohladí, kdy mu dá kostku
  - NAO uchopí kostku a hodí ji do krabice
  - NAO zaujme pozorovací pozici, poøídí snímek a rozpozná, co na kostce padlo
  - NAO øekne, co rozpoznal a oznámí protihráèi, e mùe házet
  - Protihráè hodí kostu do krabice a pohladí robota na znamení, e mùe zaèít rozpoznávat
  - NAO zaujme pozorovací pozici, poøídí snímek a rozpozná, co na kostce padlo
  - NAO øekne, co rozpoznal a oznámí protihráèi vısledek hry
  - Hra pokraèuje od bodu 2

  * Pokud dojde k chybì pøi rozpoznávání, NAO nevidí kostku, bude se hod opakovat
  * Pokud dojde k chybì pøi rozpoznávání a NAO špatnì vyhodnotí, co padlo, hra pokraèuje dál, jako by to bylo správnì. Nepøedpokládá se, e by se NAO spletl. 

==== Dílèí èásti ====
=== Modul pro rozpoznávání kostky ===
Modul, kterı je schopen, rozpoznat kostku zmiòovanou v èásti kostka, a urèit, kolik na ní padlo. Modul také pøedpokládá pouití krabice se zelenım vnitøkem a specifickou pozici robota. 

===== Moná rozšíøení =====



